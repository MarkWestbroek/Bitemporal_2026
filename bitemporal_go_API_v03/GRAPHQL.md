# GraphQL API Documentation

## Overview

Your Bitemporal API now has a full GraphQL endpoint integrated with Gin and gqlgen. The GraphQL implementation is type-safe and works directly with your Bun ORM.

## Endpoints

- **GraphQL Playground (Interactive IDE)**: `GET /graphql/playground`
- **GraphQL Query/Mutation Endpoint**: 
  - `POST /graphql/query` - Execute queries and mutations
  - `GET /graphql/query` - Execute simple GET queries

## Getting Started

### 1. Start the Server

```bash
go run main.go
```

Or use the compiled binary:
```bash
./app
```

### 2. Open GraphQL Playground

Navigate to: `http://localhost:8080/graphql/playground`

You'll see the interactive GraphQL IDE where you can:
- Write queries and mutations
- Explore the schema with auto-complete
- See real-time documentation
- Execute requests and view results

## Schema Overview

### Core Types

- **EntityA** - Entity A with lifecycle dates (opvoer/afvoer)
- **EntityB** - Entity B with lifecycle dates  
- **RelationAB** - Relationship between A and B
- **DataElementAU** - A one-to-one data element
- **DataElementAV** - A one-to-many data element
- **DataElementBX** - B one-to-one data element
- **DataElementBY** - B one-to-one data element
- **Registration** - Audit record for changes (Registratie/Correctie/Ongedaanmaking)
- **Change** - Tracks individual field changes (Wijziging)
- **Task** - Task management

### Custom Scalars

- **DateTime** - ISO 8601 formatted datetime strings (RFC3339)

## Example Queries

### Query a Task

```graphql
query {
  task(id: "task-123") {
    id
    title
    description
    status
    dueDate
  }
}
```

### Get All Tasks with Pagination

```graphql
query {
  allTasks(limit: 10, offset: 0) {
    id
    title
    status
  }
}
```

### Query Entity A

```graphql
query {
  entityA(id: "entity-a-1") {
    id
    opvoer
    afvoer
    dataElementAU {
      aaa
      bbb
    }
    dataElementsAV {
      ccc
    }
    relations {
      bId
      entityB {
        id
      }
    }
  }
}
```

## Example Mutations

### Create a Task

```graphql
mutation {
  createTask(input: {
    id: "task-1"
    title: "My Task"
    description: "Task description"
    dueDate: "2026-02-28T23:59:59Z"
    status: "pending"
  }) {
    id
    title
    status
  }
}
```

### Update a Task

```graphql
mutation {
  updateTask(id: "task-1", input: {
    title: "Updated Task"
    status: "completed"
  }) {
    id
    title
    status
  }
}
```

### Delete a Task

```graphql
mutation {
  deleteTask(id: "task-1")
}
```

## Implementation Guide

### Current Status

The GraphQL schema has been defined in `graph/schema.graphqls` with all resolvers generated by gqlgen.

**Ready to implement:**
- ✅ Task resolvers (database operations)
- ✅ DateTime scalar marshaling/unmarshaling
- ⏳ Entity A/B/Relationship resolvers
- ⏳ Data element resolvers
- ⏳ Registration/Change audit resolvers

### Implementing Resolvers

Resolvers are located in `graph/schema.resolvers.go`. Each resolver has a `panic` statement. Replace these with actual implementations.

**Pattern for implementing a resolver:**

```go
// Example: Implement EntityA resolver
func (r *queryResolver) EntityA(ctx context.Context, id string) (*model.EntityA, error) {
	var dbEntity dbmodel.A
	err := r.DB.NewSelect().Model(&dbEntity).Where("id = ?", id).Scan(ctx)
	if err != nil {
		return nil, err
	}
	
	// Convert DB model to GraphQL model
	return &model.EntityA{
		ID:     dbEntity.ID,
		Opvoer: dbEntity.Opvoer,
		Afvoer: dbEntity.Afvoer,
	}, nil
}
```

### Key Files

- `graph/schema.graphqls` - GraphQL schema definition
- `graph/schema.resolvers.go` - Resolver implementations
- `graph/model/models_gen.go` - Generated GraphQL models
- `graph/resolver.go` - Resolver dependency injection (has `*bun.DB`)
- `graph/datetime.go` - DateTime scalar marshaling
- `handlers/graphql_handler.go` - Gin integration
- `gqlgen.yml` - gqlgen configuration

### Regenerating Code

After modifying `schema.graphqls`, regenerate the code:

```bash
go run github.com/99designs/gqlgen@latest generate
```

This will:
- Update `graph/model/models_gen.go` with new types
- Add new resolver stubs in `graph/schema.resolvers.go`
- Keep your implementations intact (they won't be overwritten)

## Database Integration

The GraphQL resolver has access to the Bun database via `r.DB`:

```go
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	var task dbmodel.Task
	err := r.DB.NewSelect().Model(&task).Where("id = ?", id).Scan(ctx)
	// ...
}
```

## DateTime Handling

DateTime fields are serialized as ISO 8601 strings (RFC3339 format):

**Input example:**
```json
{
  "dueDate": "2026-02-28T23:59:59Z"
}
```

**Output example:**
```json
{
  "dueDate": "2026-02-28T23:59:59Z"
}
```

## Error Handling

GraphQL errors are automatically formatted. If a resolver returns an error, it will be included in the GraphQL response:

```json
{
  "errors": [
    {
      "message": "Error message from resolver",
      "path": ["task"],
      "extensions": {
        "code": "INTERNAL_SERVER_ERROR"
      }
    }
  ],
  "data": null
}
```

## Next Steps

1. **Implement Task Resolvers** - Start with the existing Task model since you already have it
2. **Implement Entity Resolvers** - Use Entity A/B as templates
3. **Add Filtering** - Enhance queries with filter inputs
4. **Add Sorting** - Support ordering results
5. **Batching** - Use DataLoader for N+1 query prevention
6. **Authorization** - Add middleware for security

## References

- [gqlgen Documentation](https://gqlgen.com/)
- [GraphQL Best Practices](https://graphql.org/learn/best-practices/)
- [Bun ORM Documentation](https://bun.uptrace.dev/)

package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/MarkWestbroek/Bitemporal_2026/bitemporal_go_API_v03/graph/model"
	model_db "github.com/MarkWestbroek/Bitemporal_2026/bitemporal_go_API_v03/model"
)

// CreateEntityA is the resolver for the createEntityA field.
func (r *mutationResolver) CreateEntityA(ctx context.Context, input model.CreateEntityAInput) (*model.EntityA, error) {
	now := time.Now()
	entityID, err := strconv.Atoi(input.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid entity A id: %w", err)
	}
	dbEntity := model_db.A{
		ID:     entityID,
		Opvoer: &now,
	}

	_, err = r.DB.NewInsert().Model(&dbEntity).Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create entity A: %w", err)
	}

	var opvoer, afvoer *string
	if dbEntity.Opvoer != nil {
		formatted := dbEntity.Opvoer.Format(time.RFC3339)
		opvoer = &formatted
	}
	if dbEntity.Afvoer != nil {
		formatted := dbEntity.Afvoer.Format(time.RFC3339)
		afvoer = &formatted
	}

	return &model.EntityA{
		ID:     strconv.Itoa(dbEntity.ID),
		Opvoer: opvoer,
		Afvoer: afvoer,
	}, nil
}

// UpdateEntityA is the resolver for the updateEntityA field.
func (r *mutationResolver) UpdateEntityA(ctx context.Context, id string, input model.UpdateEntityAInput) (*model.EntityA, error) {
	panic(fmt.Errorf("not implemented: UpdateEntityA - updateEntityA"))
}

// DeleteEntityA is the resolver for the deleteEntityA field.
func (r *mutationResolver) DeleteEntityA(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEntityA - deleteEntityA"))
}

// CreateEntityB is the resolver for the createEntityB field.
func (r *mutationResolver) CreateEntityB(ctx context.Context, input model.CreateEntityBInput) (*model.EntityB, error) {
	panic(fmt.Errorf("not implemented: CreateEntityB - createEntityB"))
}

// UpdateEntityB is the resolver for the updateEntityB field.
func (r *mutationResolver) UpdateEntityB(ctx context.Context, id string, input model.UpdateEntityBInput) (*model.EntityB, error) {
	panic(fmt.Errorf("not implemented: UpdateEntityB - updateEntityB"))
}

// DeleteEntityB is the resolver for the deleteEntityB field.
func (r *mutationResolver) DeleteEntityB(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteEntityB - deleteEntityB"))
}

// CreateRelationAb is the resolver for the createRelationAB field.
func (r *mutationResolver) CreateRelationAb(ctx context.Context, input model.CreateRelationABInput) (*model.RelationAb, error) {
	panic(fmt.Errorf("not implemented: CreateRelationAb - createRelationAB"))
}

// DeleteRelationAb is the resolver for the deleteRelationAB field.
func (r *mutationResolver) DeleteRelationAb(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteRelationAb - deleteRelationAB"))
}

// CreateDataElementAu is the resolver for the createDataElementAU field.
func (r *mutationResolver) CreateDataElementAu(ctx context.Context, input model.CreateDataElementAUInput) (*model.DataElementAu, error) {
	panic(fmt.Errorf("not implemented: CreateDataElementAu - createDataElementAU"))
}

// UpdateDataElementAu is the resolver for the updateDataElementAU field.
func (r *mutationResolver) UpdateDataElementAu(ctx context.Context, relID string, input model.UpdateDataElementAUInput) (*model.DataElementAu, error) {
	panic(fmt.Errorf("not implemented: UpdateDataElementAu - updateDataElementAU"))
}

// CreateDataElementAv is the resolver for the createDataElementAV field.
func (r *mutationResolver) CreateDataElementAv(ctx context.Context, input model.CreateDataElementAVInput) (*model.DataElementAv, error) {
	panic(fmt.Errorf("not implemented: CreateDataElementAv - createDataElementAV"))
}

// CreateDataElementBx is the resolver for the createDataElementBX field.
func (r *mutationResolver) CreateDataElementBx(ctx context.Context, input model.CreateDataElementBXInput) (*model.DataElementBx, error) {
	panic(fmt.Errorf("not implemented: CreateDataElementBx - createDataElementBX"))
}

// CreateDataElementBy is the resolver for the createDataElementBY field.
func (r *mutationResolver) CreateDataElementBy(ctx context.Context, input model.CreateDataElementBYInput) (*model.DataElementBy, error) {
	panic(fmt.Errorf("not implemented: CreateDataElementBy - createDataElementBY"))
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input model.CreateTaskInput) (*model.Task, error) {
	// Parse the DueDate from string format
	dueDate, err := time.Parse(time.RFC3339, input.DueDate)
	if err != nil {
		dueDate = time.Now()
	}

	dbTask := model_db.Task{
		ID:          input.ID,
		Title:       input.Title,
		Description: input.Description,
		DueDate:     dueDate,
		Status:      input.Status,
	}

	_, err = r.DB.NewInsert().Model(&dbTask).Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create task: %w", err)
	}

	return &model.Task{
		ID:          dbTask.ID,
		Title:       dbTask.Title,
		Description: dbTask.Description,
		DueDate:     dbTask.DueDate.Format(time.RFC3339),
		Status:      dbTask.Status,
	}, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, input model.UpdateTaskInput) (*model.Task, error) {
	// Fetch the existing task
	dbTask := model_db.Task{ID: id}
	err := r.DB.NewSelect().Model(&dbTask).Where("id = ?", id).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Update fields if provided
	if input.Title != nil {
		dbTask.Title = *input.Title
	}
	if input.Description != nil {
		dbTask.Description = *input.Description
	}
	if input.DueDate != nil {
		dbTask.DueDate = time.Now() // Parse from input if needed
	}
	if input.Status != nil {
		dbTask.Status = *input.Status
	}

	_, err = r.DB.NewUpdate().Model(&dbTask).WherePK().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &model.Task{
		ID:          dbTask.ID,
		Title:       dbTask.Title,
		Description: dbTask.Description,
		DueDate:     dbTask.DueDate.Format(time.RFC3339),
		Status:      dbTask.Status,
	}, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	result, err := r.DB.NewDelete().Model(&model_db.Task{}).Where("id = ?", id).Exec(ctx)
	if err != nil {
		return false, err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return false, err
	}

	return rowsAffected > 0, nil
}

// EntityA is the resolver for the entityA field.
func (r *queryResolver) EntityA(ctx context.Context, id string) (*model.EntityA, error) {
	var dbEntity model_db.A
	err := r.DB.NewSelect().Model(&dbEntity).Where("id = ?", id).Scan(ctx)
	if err != nil {
		return nil, err
	}

	// Convert DB model to GraphQL model
	var opvoer, afvoer *string
	if dbEntity.Opvoer != nil {
		formatted := dbEntity.Opvoer.Format(time.RFC3339)
		opvoer = &formatted
	}
	if dbEntity.Afvoer != nil {
		formatted := dbEntity.Afvoer.Format(time.RFC3339)
		afvoer = &formatted
	}
	return &model.EntityA{
		ID:     strconv.Itoa(dbEntity.ID),
		Opvoer: opvoer,
		Afvoer: afvoer,
	}, nil
}

// AllEntitiesA is the resolver for the allEntitiesA field.
func (r *queryResolver) AllEntitiesA(ctx context.Context, limit *int32, offset *int32) ([]*model.EntityA, error) {
	panic(fmt.Errorf("not implemented: AllEntitiesA - allEntitiesA"))
}

// EntityB is the resolver for the entityB field.
func (r *queryResolver) EntityB(ctx context.Context, id string) (*model.EntityB, error) {
	panic(fmt.Errorf("not implemented: EntityB - entityB"))
}

// AllEntitiesB is the resolver for the allEntitiesB field.
func (r *queryResolver) AllEntitiesB(ctx context.Context, limit *int32, offset *int32) ([]*model.EntityB, error) {
	panic(fmt.Errorf("not implemented: AllEntitiesB - allEntitiesB"))
}

// RelationAb is the resolver for the relationAB field.
func (r *queryResolver) RelationAb(ctx context.Context, id string) (*model.RelationAb, error) {
	panic(fmt.Errorf("not implemented: RelationAb - relationAB"))
}

// AllRelationsAb is the resolver for the allRelationsAB field.
func (r *queryResolver) AllRelationsAb(ctx context.Context, limit *int32, offset *int32) ([]*model.RelationAb, error) {
	panic(fmt.Errorf("not implemented: AllRelationsAb - allRelationsAB"))
}

// DataElementAu is the resolver for the dataElementAU field.
func (r *queryResolver) DataElementAu(ctx context.Context, relID string) (*model.DataElementAu, error) {
	panic(fmt.Errorf("not implemented: DataElementAu - dataElementAU"))
}

// DataElementsAu is the resolver for the dataElementsAU field.
func (r *queryResolver) DataElementsAu(ctx context.Context, aID string) ([]*model.DataElementAu, error) {
	panic(fmt.Errorf("not implemented: DataElementsAu - dataElementsAU"))
}

// DataElementAv is the resolver for the dataElementAV field.
func (r *queryResolver) DataElementAv(ctx context.Context, relID string) (*model.DataElementAv, error) {
	panic(fmt.Errorf("not implemented: DataElementAv - dataElementAV"))
}

// DataElementsAv is the resolver for the dataElementsAV field.
func (r *queryResolver) DataElementsAv(ctx context.Context, aID string) ([]*model.DataElementAv, error) {
	panic(fmt.Errorf("not implemented: DataElementsAv - dataElementsAV"))
}

// DataElementBx is the resolver for the dataElementBX field.
func (r *queryResolver) DataElementBx(ctx context.Context, relID string) (*model.DataElementBx, error) {
	panic(fmt.Errorf("not implemented: DataElementBx - dataElementBX"))
}

// DataElementBy is the resolver for the dataElementBY field.
func (r *queryResolver) DataElementBy(ctx context.Context, relID string) (*model.DataElementBy, error) {
	panic(fmt.Errorf("not implemented: DataElementBy - dataElementBY"))
}

// Registration is the resolver for the registration field.
func (r *queryResolver) Registration(ctx context.Context, id string) (*model.Registration, error) {
	panic(fmt.Errorf("not implemented: Registration - registration"))
}

// AllRegistrations is the resolver for the allRegistrations field.
func (r *queryResolver) AllRegistrations(ctx context.Context, limit *int32, offset *int32) ([]*model.Registration, error) {
	panic(fmt.Errorf("not implemented: AllRegistrations - allRegistrations"))
}

// Change is the resolver for the change field.
func (r *queryResolver) Change(ctx context.Context, id string) (*model.Change, error) {
	panic(fmt.Errorf("not implemented: Change - change"))
}

// AllChanges is the resolver for the allChanges field.
func (r *queryResolver) AllChanges(ctx context.Context, limit *int32, offset *int32) ([]*model.Change, error) {
	panic(fmt.Errorf("not implemented: AllChanges - allChanges"))
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string) (*model.Task, error) {
	var dbTask model_db.Task
	err := r.DB.NewSelect().Model(&dbTask).Where("id = ?", id).Scan(ctx)
	if err != nil {
		return nil, err
	}

	return &model.Task{
		ID:          dbTask.ID,
		Title:       dbTask.Title,
		Description: dbTask.Description,
		DueDate:     dbTask.DueDate.Format(time.RFC3339),
		Status:      dbTask.Status,
	}, nil
}

// AllTasks is the resolver for the allTasks field.
func (r *queryResolver) AllTasks(ctx context.Context, limit *int32, offset *int32) ([]*model.Task, error) {
	var dbTasks []model_db.Task
	query := r.DB.NewSelect().Model(&dbTasks)

	if offset != nil && *offset > 0 {
		query = query.Offset(int(*offset))
	}

	if limit != nil && *limit > 0 {
		query = query.Limit(int(*limit))
	}

	err := query.Scan(ctx)
	if err != nil {
		return nil, err
	}

	tasks := make([]*model.Task, len(dbTasks))
	for i, t := range dbTasks {
		tasks[i] = &model.Task{
			ID:          t.ID,
			Title:       t.Title,
			Description: t.Description,
			DueDate:     t.DueDate.Format(time.RFC3339),
			Status:      t.Status,
		}
	}

	return tasks, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
